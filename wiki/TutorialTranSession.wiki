
 !TranSession is guzz's persist API. It is divided into two sub interfaces, !ReadonlyTranSession for query and !WriteTranSession for write.

 A !TranSession manages a transaction, all operations in one un-auto-commit !TranSession acts in a transaction cycle until you commit or rollback it.

== !GuzzBaseDao: ==

 !GuzzBaseDao is a handy base class for implementing DAOs of your system. It provides common useful methods, and is suggested to be used for all DAOs.
 
 -*WARNING: Every persist method in !GuzzBaseDao acts in its single alone transaction! They are not prepared to work together for one transaction.*

== !ReadonlyTranSession, API for read ==

 !ReadonlyTranSession is and can be used only for querying data. Example:

{{{
TransactionManager tm = guzzContext.getTransactionManager() ;

ReadonlyTranSession session = getTransactionManager().openDelayReadTran() ;

try{
	SearchExpression se = SearchExpression.forClass(SystemLog.class) ;
	se.and(Terms.eq("categoryId", 18)) ;
	se.setOrderBy("importance desc, id asc") ;
	return session.list(se) ;
}finally{
	session.close() ;
}
}}}

 The example shows you how to fetch a !ReadonlyTranSession.

 !ReadonlyTranSession supports three query API: [SearchExpression SearchExpression] the object-oriented query language, CompiledSQL for writing sqls in your code, and Id configured in guzz.xml.

=== !SearchExpression: ===
 [SearchExpression SearchExpression] is similar to criteria in hibernate, but less powerful.
 
 Query Expression is organized and combined by [SearchExpression#SearchTerm SearchTerm]. [SearchExpression#SearchTerm Read More].

=== CompiledSQLï¼š ===

 CompiledSQL is a complement to SearchExpression, as the later one cann't be so powerful enough.
 
 CompiledSQL is a compiled version of sql, including raw sql, parameters, orm, and so on. 
 
 CompiledSQL is thread-safe, and better than normal sql for performance. 
 
 Guzz asks every sql compiled to be a CompiledSQL to execute, and suggests you to cache it.
 
 The sql to be compiled should be a sql that can be executed directly in your database, except that it can own named parameters and property-column transformation. The rule of the transformation is the same of the sqls configured in guzz.xml(@@businessName used for table name, and @propertyName used for column name). For example:

{{{
TransactionManager tm = super.getTransactionManager() ;

String sql = "update @@" + SystemLog.class.getName() +  " set @importance = :level where @id = :id" ;
CompiledSQL cs = tm.getCompiledSQLBuilder().buildCompiledSQL(SystemLog.class, sql) ;

WriteTranSession session = tm.openRWTran(true) ;

try{
	session.executeUpdate(cs.bind("level", 3).bind("id", 5)) ;
}finally{
	session.close() ;
}
}}}

 This example calls CompiledSQLBuilder's buildCompiledSQL() to build a CompiledSQL. The first parameter is used to tell guzz which database group the sql should be executed in, the second is the sql statement.

 The !WriteTranSession executes a update execution. If this is a (list) query sql, guzz will used the first parameter before to do ORM, the result returned would be List`<`SystemLog`>`.

 CompiledSQL must be binded with parameters or Loaders, and turned into a temporary object BindedCompiledSQL, before it can be handed to !TranSession. The actual sql for one execution is represented as !BindedCompiledSQL in fact.

 BindedCompiledSQL is *NOT* thread-safe, and designed to used for only one time. The parameters and other tips set in a BindedCompiledSQL only affects its own execution.
 
 For example, sometimes we need to temporary alter a sql's returned value(changing the orm), then we can use BindedCompiledSQL's setRowDataLoader(RowDataLoader) to achieve this.

 guzz carries two RowDataLoaders in default, FirstColumnDataLoader for retrieving the first column of a ResultSet, and FormBeanRowDataLoader for mapping the ResultSet to any pojo class or a Map.

 Example:

{{{
TransactionManager tm = super.getTransactionManager() ;

String sql = "select count(*) as count, company from mycompany join xxx... where group by company having @salary = :salary " ;

CompiledSQL cs = builder.buildCompiledSQL(Company.class, sql) ;

WriteTranSession session = tm.openRWTran(true) ;

try{
        //Map the ResultSet to HashMap, bind parameters, and execute the query.
	List<Map> result = session.list(cs.setRowDataLoader(FormBeanRowDataLoader.newInstanceForClass(HashMap.class)).bind("salary", 3000)) ;
}finally{
	session.close() ;
}
}}}

 In the example, we use FormBeanRowDataLoader to map the result to a java.util.HashMap, not the default Company.class.
 
 RowDataLoader is the interface to handle how to map a row of the java.sql.ResultSet in query to a java object instance. It is light-weight, and is recommended to use for any special OR mappings in your system.

=== Query by Id configured in guzz.xml: ===

 Similar to ibatis. [TutorialGuzzXml Read more about how to write the xml].

== !WriteTranSession, API for write ==

 WriteTranSession is the API interface for performing updating operations the databases. In a master-slave database architecture, WriteTranSession operates the master database only.
 
{{{
TransactionManager tm = super.getTransactionManager() ;
WriteTranSession session = tm.openRWTran(true) ;
}}}

 To create a WriteTranSession, we need to pass a boolean parameter to indicate how to control the transaction. true: auto-commit; false:commit manually.

 If you pass false to create a un-auto-commit transaction, remember to call session.commit() to commit the transaction, or call session.rollback() to roll back it.

 WriteTranSession only allows querying a record by primary key. If you need to query data from the master database with more options, open a !ReadonlyTranSession with no delay to do it.

== Batch: ==
 
 There are two ways to do batch updating in guzz, by object or by sql statement. In both ways, you need to open a WriteTranSession first.

 -*By object:*
{{{
		WriteTranSession session = tm.openRWTran(false) ;
		ObjectBatcher batcher = session.createObjectBatcher() ;
				
		for(int loop = 0 ; loop < 1000 ; loop++){
			User user = new User() ;
			user.setUserName("hello un " + i) ;
				
			batcher.insert(user) ;
		}

                batcher.executeUpdate() ;
		session.commit() ;

		session.close() ;
}}}

 -*By sql statement:*
{{{
CompiledSQL cs = tm.getCompiledSQLBuilder().buildCompiledSQL(User.class, "delete from @@" + User.class.getName() + " where @id = :id") ;

WriteTranSession session = tm.openRWTran(false) ;
SQLBatcher batcher = session.createCompiledSQLBatcher(cs) ;

for(int loop = 0 ; loop < 100 ; loop++){
	batcher.addNewBatchParams("id", user.getId()) ;
}
	
batcher.executeUpdate() ;
session.commit() ;

}}}

 After opening a WriteTranSession, create a Batcher, add objects or parameters to the batcher as its API required, then executeUpdate.
 
 -*NOTE:* A batcher can be used only for a single business domain's single operation in a single table. If you need to operate multiple tables at once, create multiple batcher for each table.
 
== Atom of Transaction: ==

 A WriteTranSession holds a transaction. If you need to handle a long transaction, call tm.openRWTran(false) to open a manual controlled (un-auto-commit) one.

 In a un-auto-commit WriteTranSession, any methods executed would be under only one transaction, no matter which database it actually operated. Even if you create a JDBCTemplate or a Batcher from it, the methods in the JDBCTemplate and Batcher would under the same transaction.

 When you call commit() or rollback(), the transaction would be committed or rolled-back fully.
 
 Guzz will take care of the distributed transaction among your configured multiple databases.
 
 
 
 