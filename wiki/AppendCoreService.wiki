== Introduction ==

 Guzz distributes itself with some common used services built in to avoid recoding. In 1.2.8 and later, you will find 5 services in the jar: Debug service, Dynamic SQL Service, Count update queue service(client and server), and insert queue service. You can use it directly in your project.

== 1. Debug Service: ==

*purpose:* Turn on/off the output of executed sqls. Set system run level.

*Interface:* org.guzz.service.core.DebugService

*Service name:* guzzDebug

*Used inside guzz:*

 * 1. guzz will pass all sqls and their parameters to debugService. The built-in debugService will output the sqls and parameters by your configurations.
 * 2. When defining database groups in guzz.xml(dbgroup), you can miss configurations in the properties file for masterDBConfigName and slaveDBConfigName in "debug" run level. But in "production" run level, guzz will raise a exception.

*Declare Service:* Not required. Guzz will load it on startup. The application can override the default implementation by declaring a service named guzzDebug.

*Service Parameters(configure in properties file):* 

{{{
[guzzDebug]
#runMode=debug/production
runMode=debug

#how to handle unexpected exceptions?
#onError=halt/log/ignore
onError=halt

#print sql statements to the commons log?
printSQL=true

#print sql parameters to the commons log?
printSQLParams=true

#ignore sqls executed in guzz demon thread(thread is demon and thread name is started with gz_demon_t_).
#org.guzz.service.core.DebugService.DEMON_NAME_PREFIX = "gz_demon_t_" ;
ignoreDemonThreadSQL=true

}}}

The configuration group name must be guzzDebug.

== 2. Dynamic SQL Service: ==

*purpose:* Load sql by id dynamically. Guzz allows you to configure your sqls in guzz.xml, and use it by id as ibatis does. But, when you need to change or add a sql, you have to modify the guzz.xml, and restart the whole application to take effects. With DynamicSQLService, you can define your own sql-source, change and load the sqls by yourself in a online system, without any restarts. Dynamic SQL is a good choice for:
 * 1. Tune Performance. Replace a old sql with a new one without restarting.
 * 2. Dynamic data source. When a new feature is required, add a new sql and its mapping online, then you can query the data by a id, parameters for the sql and pagination through a common servlet(the servlet just has to pass querying to guzz with the passed id and parameters), and return the queried results in json or xml. Then, what you need to do is just to write a ajax script and build your pages.

*Interface:* org.guzz.service.core.DynamicSQLService

*Service name:* guzzDynamicSQL

*Used inside guzz:*

 * 1. Guzz query DynamicSQLService for a sql by id when executing sqls by id.

*Declare Service:* Configure a service implements org.guzz.service.core.DynamicSQLService with the service name of guzzDynamicSQL.

*Default Implementation in guzz:* guzz distributes a default DynamicSQLService based on file system. Each xml file contains a sql and its mapping, and the sql id is the file name without the suffix of ".xml".

 How to configure?

 Declare in guzz.xml:
 {{{
 <service name="guzzDynamicSQL" configName="guzzDynamicSQL" class="org.guzz.service.core.impl.FileDynamicSQLServiceImpl" />
 }}}

 and add configurations in the properties file:

 {{{
 [guzzDynamicSQL]
 #where to find the sql .xml files
 folder=/nas/conf/sqls/

 #file encoding
 encoding=UTF-8

 #When both this service and the guzz.xml have defined a sql for a same id, which one takes a priority? true: use sql from this service. false: use sql in the guzz.xml.
 overrideSqlInGuzzXML=false

 #cache the parsed sql in memory until the file changed?
 useCache=true
 }}}

Notes: the service name must be: guzzDynamicSQL

== 3. Count update queue service(Client): ==

*purpose:* Log operations for increment or decrement a count number column by primary key to a temporary table. In the meantime, a demon thread reads operations from the temporary table, combines operations for the a record, and updates back to the main table. This service is usually used in a big site to handle the count updating bottle-neck of database. This service is the client side, and handles the part of writing to a temporary table.

*Interface:* org.guzz.service.core.SlowUpdateService

*Service name:* guzzSlowUpdate

*Used inside guzz:*
 * 1. g:inc taglib uses this service to do count updating. If this service is not available, g:inc won't work!

Guzz ships with 2 versions of the client implementations. If you have many objects to update, such as message's readCount in twitter, use the first one; If you have less objects to update, but they would be updated very very frequent, like super star's visit count in twitter, use the later one.

*Declare Service For the first one:* The first one is declared in guzz by default. But you have to add a business declaration in guzz.xml:

{{{
<business dbgroup="updateDB" name="guzzSlowUpdate" file="classpath:xxx/IncUpdateBusiness.hbm.xml" />
}}}

 IncUpdateBusiness.hbm.xml is stored under org.guzz.service.core.impl in guzz's jar file. You need to copy it to somewhere guzz can load, and create the corresponding table with the sqls provided inside IncUpdateBusiness.hbm.xml.

 IncUpdateBusiness holds the counting operations, and will be stored in the temporary table.

 And you also have to add the configuration parameters for the service in the properties file:

{{{
[guzzSlowUpdate]
#max size of cached queue
queueSize=20480

#batch size for updating to the temporary database.
batchSize=2048
}}}

*Declare Service For the later one:*

 guzz.xml：

{{{
<service name="guzzSlowUpdate" configName="guzzSuperSlowUpdate" class="org.guzz.service.core.impl.SuperSlowUpdateServiceImpl" />

<business dbgroup="updateDB" name="guzzSlowUpdate" file="classpath:xxx/IncUpdateBusiness.hbm.xml" />
}}}

 Override the default one with the same service name. (You can also write your own implementation, and override the default)

 properties file:

{{{
[guzzSuperSlowUpdate]
#batch size for updating to the temporary database.
batchSize=2048

#how many millseconds to wait when there is no new updates available.
updateInterval=500
}}} 

*Java API to call the service:*

 1. Fetch guzzSlowUpdate service. The service's java interface is: org.guzz.service.core.SlowUpdateService
 
 2. Call its methods.
 
{{{
public interface SlowUpdateService {
	
	/**
	 * update a count. Used inside.
	 * 
	 * @param dbGroup dbgroup to update
	 * @param tableName table name to update
	 * @param columnToUpdate column name to update
	 * @param pkColName primary column name of the table to be updated
	 * @param pkValue primary key
	 * @param countToInc count to inc
	 */
	public void updateCount(String dbGroup, String tableName, String columnToUpdate, String pkColName, Serializable pkValue, int countToInc) ;
	
	
	/**
	 * update a count.
	 * 
	 * @param businessName business name
	 * @param tableCondition shadow table. Pass null if shadow is not used.
	 * @param propToUpdate the java property name to be updated.
	 * @param pkValue the primary property value.
	 * @param countToInc count to inc
	 */
	public void updateCount(String businessName, Object tableCondition, String propToUpdate, Serializable pkValue, int countToInc) ;
	
	
	/**
	 * update a count.
	 * 
	 * @param domainClass business domain class
	 * @param tableCondition shadow table. Pass null if shadow is not used.
	 * @param propToUpdate the java property name to be updated.
	 * @param pkValue the primary property value.
	 * @param countToInc count to inc
	 */
	public void updateCount(Class domainClass, Object tableCondition, String propToUpdate, Serializable pkValue, int countToInc) ;

}

}}}
 
*Taglib API: *

 Use g:inc taglib to do the updating in the JSP file.

== 4. Count update queue service(Server-side): ==

*用途：* 完成从临时表到主库的更新操作。此服务1个临时表只允许1个实例运行，不支持集群，但可以和客户端服务同时运行。

*接口：*org.guzz.service.db.SlowUpdateServer

*注册服务名称：* 自定义，推荐slowUpdateServer

*guzz内部使用范围：* 内部不使用

*配置方法：*

 guzz.xml：

{{{
<service name="slowUpdateServer" configName="guzzSlowUpdateServer" class="org.guzz.service.db.impl.SlowUpdateServerImpl" />
}}}

 properties文件：

{{{
[guzzSlowUpdateServer]
#batch size for updating the main database
batchSize=50

#page size for reading from the temp table
pageSize=40

#how many pages to read from the temp table for one loop updating
combinePageCount=10

#millseconds to wait for the next round of updates checking
updateInterval=500
}}}

*内部工作原理：* slowUpdateServer一次从临时表读取pageSize*combinePageCount条记录，进行一次sql更新合并，然后按照batchSize创建批处理写入到主库中。

*提示：* slowUpdateServer需要在guzz.xml中和properties文件中都配置时才会启动。一般我们将slowUpdate和slowUpdateServer一起配置到guzz.xml中，但只在其中1台机器上配置slowUpdateServer的properties参数，以保证只有1台机器启动后台同步服务（将临时表更新到主库中）。这样开发与生产系统中的guzz.xml都可以保持一份，每台机器唯一需要额外处理的就是properties参数文件。

*提示2：* 计数sql合并的效果可以通过在log4j.properties中增加一行：

{{{
log4j.logger.org.guzz.service.db.impl=debug
}}}

 来观察输出。

== 5. 日志队列服务： ==

*用途：* 将1个对象写入队列，另外1个后台线程将队列中的元素写入到数据库中。用于应用处理不太重要但又可能影响性能的数据库写操作。

*接口：*org.guzz.service.log.LogService

*注册服务名称：* 自定义，推荐logService

*guzz内部使用范围：* 内部不使用

*配置方法：*

 guzz.xml：

{{{
<service name="logService" configName="guzzDBLogServiceClient" class="org.guzz.service.log.impl.DBLogServiceImpl" />

}}}

 properties文件：

{{{
[guzzDBLogServiceClient]
#commit size
commitSize=2048

#max size of log queue
queueSize=20480
}}}

*内部工作原理：* 与默认的slowUpdate服务相同。唯一不同的是logService允许同时插入不同的领域对象，配置的commitSize用于表示执行多少次sql进行一次commit操作。logService处理的对象一般是应用系统自己定义的对象。
 