
== 概述 ==

 guzz自身携带了一些常用的服务，供项目方便使用。主要有：调试信息服务，计数器更新队列服务以及日志队列服务。

== 1. 调试信息服务： ==

*用途：*用于打开或者关闭数据库输出日志，设置系统运行级别。

*接口：*org.guzz.service.core.DebugService

*服务注册名称：*debugService

*guzz内部使用范围：*

 * 1. guzz在执行数据库操作时，将所有使用的sql语句以及参数传递给debugService进行输出记录。
 * 2. guzz.xml中进行数据库定义时（dbgroup），在debug模式下允许填写的masterDBConfigName或slaveDBConfigName在properties文件中不存在；而在production模式下不允许。

*配置加载方法：*不需要配置，guzz启动时自动加载。

*服务参数（properties文件定义）：* 

{{{
[guzzDebug]
#runMode=debug/production
runMode=debug

#how to handle unexpected exceptions?
#onError=halt/log/ignore
onError=halt

#print sql statements to the commons log?
printSQL=true

#print sql parameters to the commons log?
printSQLParams=true

#ignore sqls executed in guzz demon thread(thread is demon and thread name is started with gz_demon_t_).
#org.guzz.service.core.DebugService.DEMON_NAME_PREFIX = "gz_demon_t_" ;
ignoreDemonThreadSQL=true

}}}

服务组名称必须为guzzDebug

== 2. 计数器更新队列服务（客户端）： ==

*用途：* 将按照主键进行字段增加或减少的计数sql操作，通过队列写入临时表。同时另外一个后台线程读取临时表数据，合并对同一条记录的操作，再写回主库进行更新操作。一般用于处理大型网站计数操作的数据库性能瓶颈。本服务为客户端，完成写入到临时表部分的操作。

*接口：*org.guzz.service.core.SlowUpdateService

*注册服务名称：*slowUpdate

*guzz内部使用范围：*
 * 1. guzz taglib的 g:inc 标签进行计数器更新时，实际上都转入此服务执行。如果此服务没有配置，g:inc标签无法使用。

guzz实现了2个版本的计数器更新，一个用于处理要更新对象很多的场景（如twitter消息阅读次数），一个用于处理要更新对象很少但更新非常频繁的场景（如twitter上超级明星消息阅读次数），默认是前者。

*前者配置方法：*

 guzz.xml：service不需要配置，默认启动。对临时表映射需要增加一行配置：

{{{
<business dbgroup="updateDB" name="guzzSlowUpdate" file="classpath:xxx/IncUpdateBusiness.hbm.xml" />
}}}

 IncUpdateBusiness.hbm.xml存储在org.guzz.service.core.impl中，需要复制到应用可以找到的目录下。临时表的sql创建语句在IncUpdateBusiness.hbm.xml注释中可以找到。

 properties文件：

{{{
[guzzSlowUpdate]
#max size of cached queue
queueSize=20480

#batch size for updating main database.
batchSize=2048
}}}

 内部工作原理：根据参数queueSize创建一个数组，所有更新操作，记录到数组的1个位置。后台1个线程重复轮询数组，将操作按照所影响数据库的行进行合并，创建批操作，根据batchSize大小将合并后的更新操作写入临时表。执行成功后，将涉及到的数组元素清空，供下次使用。所有操作，没有锁处理。因此，如果queueSize比较小，而计数非常频繁，会出现数组元素被覆盖，计数器漏记。

*后者配置方法：*

 guzz.xml：

{{{
<service name="slowUpdate" configName="guzzSuperSlowUpdate" class="org.guzz.service.core.impl.SuperSlowUpdateServiceImpl" />

<business dbgroup="updateDB" name="guzzSlowUpdate" file="classpath:xxx/IncUpdateBusiness.hbm.xml" />
}}}

 用同名的服务，覆盖默认实现。

 properties文件：

{{{
[guzzSuperSlowUpdate]
#batch size for updating to the main database.
batchSize=2048

#how many milseconds to wait if there is no new updates available.
updateInterval=1000
}}}

 内部工作原理：创建1个Map，每次对1个新行的更新都都记录到Map中，如果是对同一行记录的更新，将Map中计数更新（合并更新操作）。后台有1个线程，轮询Map，将Map中记录到的更新操作按照batchSize创建批操作写入临时表，并将计数设置为0（已经完成数据库更新）；如果元素计数为0，表示从上次入库到现在没有新的更新，判定此元素不再活跃，从Map中删除。如果1次轮询，没有任何需要更新的记录，线程等待updateInterval毫秒后执行。

== 3. 计数器更新队列服务（服务器端）： ==

*用途：* 完成从临时表到主库的更新操作。此服务1个临时表只允许1个实例运行，不支持集群，但可以和客户端服务同时运行。

*接口：*org.guzz.service.db.SlowUpdateServer

*注册服务名称：* 自定义，推荐slowUpdateServer

*guzz内部使用范围：* 内部不使用

*配置方法：*

 guzz.xml：

{{{
<service name="slowUpdateServer" configName="guzzSlowUpdateServer" class="org.guzz.service.db.impl.SlowUpdateServerImpl" />
}}}

 properties文件：

{{{
[guzzSlowUpdateServer]
#batch size for updating the main database
batchSize=50

#page size for reading from the temp table
pageSize=40

#how many pages to read from the temp table for one loop updating
combinePageCount=10
}}}

 slowUpdateServer一次从临时表读取pageSize*combinePageCount条记录，进行一次更新sql合并，然后按照batchSize写入到主库中。

*提示：* slowUpdateServer需要在guzz.xml中和properties文件中都配置时才会启动。一般我们将slowUpdate和slowUpdateServer一起配置到guzz.xml中，但只在其中1台机器上配置slowUpdateServer的properties参数，以保证只有1台机器启动后台同步服务（将临时表更新到主库中）。这样开发与生产系统中的guzz.xml都可以保持一份，每台机器唯一需要额外处理的就是properties参数文件。

*提示2：* 计数sql合并的效果可以通过在log4j.properties中增加一行：

{{{
log4j.logger.org.guzz.service.db.impl=debug
}}}

 来观察输出。

== 4. 日志队列服务： ==

*用途：* 将1个对象写入队列，另外1个后台线程将队列中的元素写入到数据库中。用于应用处理不太重要但又可能影响性能的数据库写操作。

*接口：*org.guzz.service.log.LogService

*注册服务名称：* 自定义，推荐logService

*guzz内部使用范围：* 内部不使用

*配置方法：*

 guzz.xml：

{{{
<service name="logService" configName="guzzDBLogServiceClient" class="org.guzz.service.log.impl.DBLogServiceImpl" />

}}}

 properties文件：

{{{
[guzzDBLogServiceClient]
#commit size
batchSize=2048

#max size of log queue
queueSize=20480
}}}

 内部工作原理：与默认的slowUpdate服务相同。唯一不同的是logService允许同时插入不同的领域对象，配置的batchSize用于表示执行多少次sql进行一次commit操作。logService处理的对象一般是应用系统自己定义的对象。