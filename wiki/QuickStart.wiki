== Guzz入门教程 ==

 在本教程中，我们将手把手的演示如何使用guzz，写一个可以并行使用5台甚至更多数据库的留言板系统。

 您可以跟着做，在实际的教程做，只需要1台数据库用来模拟。
 
 本教程的大致内容包括：如何创建guzz项目，如何用guzz添加数据库纪录，如何实现读写分离，如何进行多数据库之间分表，切表，分布式切表等。最后部分简单介绍 计数器队列 的使用，再拿基础服务做一个“可以手工干预，定期自动发布的排行榜，用来统计留言最多的用户”。

== 教程目录大纲  ==

 * 1. 什么guzz？什么时候用？

 * 2. 准备环境

 * 3. 创建MessageBoard工程

 * 4. 配置工程，插入第1条留言

 * 5. 实现读写分离（启用第2台数据库）

 * 6. 实现1个多用户留言板

 * 7. 使用2组数据库（启用第3，4台数据库）

 * 8. 将留言表分切成小表

 * 9. 分布式切表以应对超级大表

 * 10. 用计数器服务实现支持投票（启用第3组，第5台数据库）

 * 11. 删除留言，批量删除留言。

 * 12. 留言最多的用户排行榜（云服务）

== 什么guzz？什么时候用？  ==

 guzz[ˈɡuzi]念做谷子。稻谷的谷，意为种子，谷物等。

 guzz和hibernate，ibatis同属于数据持久层框架，在应用架构上用于代替hibernate或者ibatis。 传统的ssh（spring + struts + hibernate）程序基于guzz架构后就是ssg（spring + struts + guzz）。同时guzz可以和hibernate/ibatis并存，同时使用。

 guzz适合于大型系统使用，包括访问量较大的系统和数据量较大的系统。当你的程序需要同时使用多台数据库，或者存在大表需要分切成小表时，guzz是目前通用持久层框架中最好的选择。guzz提供了面向未来的配置化分表，多库，表分切，读写分离，以及多台数据库之间透明的分布式事务支持，使得多数据库编程和普通编程一样简单，对开发者透明。
 
 同时guzz提供一些服务定义，帮助团队从零开始创建云服务计算平台。如果您计划将多个系统间的通用计算（功能）做成服务，并且还没有动手，guzz service将是个很好的起步点。

== 准备环境  ==

在本教程中，我们使用MyEclipse IDE做开发演示。留言板将运行在1台Mysql5.0 + 1台Tomcat6上。因此您只需要自己的开发机器就可以跟上。

当然，如果你有5台或者更多数据库，会更好。

虽然教程中只有1台数据库，但效果一样，guzz用多台数据库和用1台对开发者是透明的。

== 创建MessageBoard工程  ==

 我们的例子使用springIOC + springMVC + guzz架构创建留言板，因此先从guzz网站下载提供的空工程a empty sample project buildxxxxxxx.zip ：[http://code.google.com/p/guzz/downloads/list]

 解压工程，并导入到Eclipse中（File -> Import -> General/Exsiting Projects into Workspace）。
 
 这时工作区中多了一个“GuzzEmpty”项目，选择项目，右键 -> Refactor -> Rename。输入MessageBoard，确定。

 从 [http://code.google.com/p/guzz/downloads/list] 下载最新版的guzz发布包，如“guzz1.2.9 buildxxxxxx.zip”，解压文件，并将guzz.jar和src.zip覆盖到刚刚创建的MessageBoard工程的 /WebRoot/WEB-INF/lib/ 下。

 修改 /WebRoot/WEB-INF/ 下的 fms.properties 为messageBoard.properties。


== 配置工程，插入第1条留言 ==

=== 配置工程 ===

 我们定义留言为Message，在src源代码目录下创建example/business/Message.java：
 {{{
	package example.business;

	import java.util.Date;

	public class Message implements java.io.Serializable {
		
		private int id ;

		private String content ;
		
		private Date createdTime ;
		
		public int getId() {
			return id;
		}

		public void setId(int id) {
			this.id = id;
		}

		public String getContent() {
			return content;
		}

		public void setContent(String content) {
			this.content = content;
		}

		public Date getCreatedTime() {
			return createdTime;
		}

		public void setCreatedTime(Date createdTime) {
			this.createdTime = createdTime;
		}
		
	}
 }}}

同时在 example/business/ 目录下创建映射文件 Message.hbm.xml：
{{{
	<?xml version="1.0"?>
	<!DOCTYPE hibernate-mapping PUBLIC "-//Hibernate/Hibernate Mapping DTD 3.0//EN"
	"http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd">
	<hibernate-mapping>
		<class name="example.business.Message" table="tb_message">
			<id name="id" type="int" column="id">
				<generator class="native" />
			</id>
			<property name="content" type="string" column="content" />
			<property name="createdTime" type="datetime" column="createdTime" />
		</class>
	</hibernate-mapping>
}}}

在映射文件中，留言存储在tb_message表中。tb_message用content字段存储留言内容。

启动并连上Mysql5.0，创建测试用数据库mb_main，并在其中创建表tb_message。sql语句如下：
{{{
create database mb_main default character set utf8 ;

use mb_main ;

create table tb_message(
	id int not null auto_increment primary key, 
	content text, 
	createdTime datetime
)engine=Innodb ;

}}}

现在我们创建连接池，让mb_main数据库和MessageBoard工程对接上。

打开/WebRoot/WEB-INF/guzz.xml文件，进入源代码编辑；右键选择 /WebRoot/WEB-INF/messageBoard.properties -> Open With -> Properties File Editor（注意：不能用高级可视化编辑器打开），打开主配置文件。

修改guzz.xml：删除默认配置的3组数据库组中的updateDB和logDB；修改fms.properties主配置文件名为我们的messageBoard.properties；删除2个服务；在business中增加Message域对象。修改后的guzz.xml为：
{{{
	<?xml version="1.0" encoding="UTF-8"?>
	<!DOCTYPE guzz-configs PUBLIC "-//GUZZ//DTD MAIN CONFIG//EN" "http://www.guzz.org/dtd/guzz.dtd">

	<guzz-configs>
		
		<dialect class="org.guzz.dialect.Mysql5Dialect" />
		
		<tran>
			<dbgroup name="default" masterDBConfigName="masterDB" />
		</tran>
		
		<config-server>
			<server class="org.guzz.config.LocalFileConfigServer">
				<param name="resource" value="messageBoard.properties" />
			</server>
		</config-server>
		
		<!-- business starts -->
		<business dbgroup="default" name="message" file="classpath:example/business/Message.hbm.xml" />
		<!-- business ends -->

	</guzz-configs>
}}}

在新的guzz.xml中，留言对象使用default数据库组，default数据库组的master数据库的配置组名称为“masterDB”，没有slave数据库。修改刚刚打开的messageBoard.properties，修改[masterDB]配置组的连接池，指向我们刚才创建的数据库mb_main。其他数据库组配置删除。新的messageBoard.properties如下：
{{{
	#guzz app config file.
	 
	#master db
	[masterDB]
	guzz.identifer=defaultMasterDB1
	guzz.IP=localhost
	guzz.maxLoad=120
	driverClass=com.mysql.jdbc.Driver
	jdbcUrl=jdbc:mysql://localhost:3306/mb_main?useUnicode=true&amp;characterEncoding=UTF-8&amp;useServerPrepStmts=true
	user=root
	password=root
	acquireIncrement=10
	idleConnectionTestPeriod=60
	 
	#debug settings
	[guzzDebug]
	#runMode=debug/production
	runMode=debug
	#onError=halt/log/ignore
	onError=halt
	printSQL=true
	printSQLParams=true
	ignoreDemonThreadSQL=true
	#print out how many nano-seconds a sql takes to execute.
	measureTime=true
	#only print out slow sqls that takes over xxx mill-seconds to execute. 0 means print out all.
	onlySlowSQLInMillSeconds=0

	############################### fundamental services #####################

}}}

打开 /WebRoot/WEB-INF/applicationContext.xml，删除bean:logService。

部署工程到Tomcat6上，然后启动。如果没有错误，则配置已经成功。如果报错，请检查数据库是否给予了访问授权。

停止tomcat6.

=== 插入留言 ===

下面我们开始插入第一条留言。在/WebRoot/下创建jsp文件：messagesList.jsp，内容如下：
{{{
	<%@ page language="java" pageEncoding="UTF-8"%>
	<%@include file="/WEB-INF/jsp/include/tags.jsp"%>

	<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
	<html>
	  <head>    
		<title>Message List</title>
	  </head>
	  
	  <body>
		
		Leave a message:<br>
		
		<form method="POST" action="./newMessage.do">
			<textarea name="content" cols="80" rows="10"></textarea>
			
			<br/>
			<input type="submit" />
		</form>
	  </body>
	</html>
}}}

创建java文件：example.view.action.NewMessageAction.java，内容如下：
{{{
	package example.view.action;

	import javax.servlet.http.HttpServletRequest;
	import javax.servlet.http.HttpServletResponse;

	import org.guzz.GuzzContext;
	import org.guzz.transaction.WriteTranSession;
	import org.springframework.web.servlet.ModelAndView;
	import org.springframework.web.servlet.mvc.Controller;

	import example.business.Message;

	public class NewMessageAction implements Controller {
		
		private GuzzContext guzzContext ;

		public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) throws Exception {
			String content = request.getParameter("content") ;
			
			WriteTranSession write = guzzContext.getTransactionManager().openRWTran(true) ;
			
			Message msg = new Message() ;
			msg.setContent(content) ;
			msg.setCreatedTime(new java.util.Date()) ;
			
			try{
				write.insert(msg) ;
			}finally{
				write.close() ;
			}
			
			return new ModelAndView("redirect:/messageList.jsp");
		}

		public GuzzContext getGuzzContext() {
			return guzzContext;
		}

		public void setGuzzContext(GuzzContext guzzContext) {
			this.guzzContext = guzzContext;
		}

	}
}}}

修改/WebRoot/WEB-INF/dispatcher-servlet.xml文件，增加springMVC映射bean：
{{{	
	<bean name="/newMessage.do" class="example.view.action.NewMessageAction">
		<property name="guzzContext" ref="guzzContext" />
	</bean>
}}}

部署程序，启动Tomcat6，访问：http://localhost:8080/guzz/messageList.jsp ，输入留言“I am the first message. What about you?”，提交。

打开数据tb_message表，可以看到1条记录已经成功插入。

=== 分页列出留言 ===

我们在messageList.jsp中列出所有发表的留言，每页30条，分页显示。使用guzz taglib实现。messageList.jsp 内容如下；
{{{
<%@ page language="java" pageEncoding="UTF-8"%>
<%@include file="/WEB-INF/jsp/include/tags.jsp"%>
<g:page business="message" var="m_messages" pageNo="${param.pageNo}" pageSize="30" orderBy="id desc" scope="request" />

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
  <head>    
    <title>Message List</title>
  </head>
  
  <body> 
  	 
  	Leave a message:<br>
  	
  	<form method="POST" action="./newMessage.do">
  		<textarea name="content" cols="80" rows="10"></textarea>
  		
  		<br/>
  		<input type="submit" />
  	</form>
  	
  	<hr>
  	<table width="96%" border="1">
  		<tr>
  			<th>No.</th>
  			<th>Content</th>
  			<th>Date</th>
  		</tr>
  		
  		<c:forEach items="${m_messages.elements}" var="m_msg">
  		<tr>
  			<td>${m_messages.index}</td>
  			<td><g:out value="${m_msg.content}" escapeXml="false" escapeScriptCode="true" /></td>
  			<td>${m_msg.createdTime}</td>
  		</tr>
  		</c:forEach>
  	</table>
  	
  	<table width="96%" border="1">
  		<tr>
  			<c:import url="/WEB-INF/jsp/include/console_flip.jsp" />
  		</tr>
  	</table>
  	
  </body>
</html>
}}}

在这个jsp中，
	{{{<g:page business="message" var="m_messages" pageNo="${param.pageNo}" pageSize="30" orderBy="id desc" scope="request" />}}} 
根据当前传入的页码查询message，并按照id desc排序。然后我们用1个c:forEach循环，打印出结果。用m_messages.index打印出当前记录从1开始的排序位置，用g:out标签打印出允许html元素但不允许script执行的正文。最后引用通用的分页文件 /WEB-INF/jsp/include/console_flip.jsp 显示分页情况。

再次访问：http://localhost:8080/guzz/messageList.jsp ，可以看到分页显示的留言列表如下：

<img width="500px" src="http://guzz.googlecode.com/svn/wiki/no-wikis/messageList.png" />

== 实现读写分离（启用第2台数据库）==

如果你有多台数据库，创建mb_main数据库的从库（具体可参看[http://guzz.javaeye.com/blog/366508]）。修改guzz.xml的
	{{{<dbgroup name="default" masterDBConfigName="masterDB" />}}}

增加从数据库配置属性slaveDBConfigName，我们设置值为slaveDB。如下：
	{{{<dbgroup name="default" masterDBConfigName="masterDB" slaveDBConfigName="slaveDB" />}}}

在messageBoard.properties文件增加slaveDB配置项的具体信息，如下：
{{{

[slaveDB]
guzz.identifer=defaultSlaveDB1
guzz.IP=localhost
guzz.maxLoad=80
driverClass=com.mysql.jdbc.Driver
jdbcUrl=jdbc:mysql://localhost:3306/mb_main?useUnicode=true&amp;characterEncoding=UTF-8&amp;useServerPrepStmts=true
user=root
password=root
acquireIncrement=10
idleConnectionTestPeriod=60

}}}

如果你有单独的从数据库，jdbcUrl处修改为从库地址即可。此时完成的messageBoard.properties文件为：
{{{
#guzz app config file.
 
#master db
[masterDB]
guzz.identifer=defaultMasterDB1
guzz.IP=localhost
guzz.maxLoad=120
driverClass=com.mysql.jdbc.Driver
jdbcUrl=jdbc:mysql://localhost:3306/mb_main?useUnicode=true&amp;characterEncoding=UTF-8&amp;useServerPrepStmts=true
user=root
password=root
acquireIncrement=10
idleConnectionTestPeriod=60

[slaveDB]
guzz.identifer=defaultSlaveDB1
guzz.IP=localhost
guzz.maxLoad=80
driverClass=com.mysql.jdbc.Driver
jdbcUrl=jdbc:mysql://localhost:3306/mb_main?useUnicode=true&amp;characterEncoding=UTF-8&amp;useServerPrepStmts=true
user=root
password=root
acquireIncrement=10
idleConnectionTestPeriod=60
 
#debug settings
[guzzDebug]
#runMode=debug/production
runMode=debug
#onError=halt/log/ignore
onError=halt
printSQL=true
printSQLParams=true
ignoreDemonThreadSQL=true
#print out how many nano-seconds a sql takes to execute.
measureTime=true
#only print out slow sqls that takes over xxx mill-seconds to execute. 0 means print out all.
onlySlowSQLInMillSeconds=0

############################### fundamental services #####################
 
}}}

至此，即完成了读写分离的配置。系统启动后，将创建两个连接池，上面留言读取的g:page将自动从slave数据库连接操作。在调用guzz持久化API时，所有选择允许延迟的读操作也将从slave连接池操作。

== 实现1个多用户留言板 ==

为了实现多用户留言板，首先我们需要增加User域对象。User对象只有三个属性，用户编号，用户名和留言数。创建example.business.User.java:
{{{
package example.business;

public class User implements java.io.Serializable {
	
	private int id ;

	private String userName ;
	
	private int messageCount ;
	
	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public String getUserName() {
		return userName;
	}

	public void setUserName(String userName) {
		this.userName = userName;
	}

	public int getMessageCount() {
		return messageCount;
	}

	public void setMessageCount(int messageCount) {
		this.messageCount = messageCount;
	}
	
}
}}}

创建映射文件User.hbm.xml：
{{{
<?xml version="1.0"?>
<!DOCTYPE hibernate-mapping PUBLIC "-//Hibernate/Hibernate Mapping DTD 3.0//EN"
"http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd">
<hibernate-mapping>
    <class name="example.business.User" table="tb_user">
        <id name="id" type="int" column="id">
        	<generator class="native" />
        </id>
        <property name="userName" type="string" column="userName" />
        <property name="messageCount" type="int" column="messageCount" />
    </class>
</hibernate-mapping>
}}}

同时在Message.java，Message.hbm.xml，增加userId属性对应User对象的id属性。新的Message.java和Message.hbm.xml为：
{{{
package example.business;

import java.util.Date;

public class Message implements java.io.Serializable {
	
	private int id ;

	private String content ;
	
	private int userId ;
	
	private Date createdTime ;
	
	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public String getContent() {
		return content;
	}

	public void setContent(String content) {
		this.content = content;
	}

	public Date getCreatedTime() {
		return createdTime;
	}

	public void setCreatedTime(Date createdTime) {
		this.createdTime = createdTime;
	}

	public int getUserId() {
		return userId;
	}

	public void setUserId(int userId) {
		this.userId = userId;
	}
	
}
}}}

{{{
<?xml version="1.0"?>
<!DOCTYPE hibernate-mapping PUBLIC "-//Hibernate/Hibernate Mapping DTD 3.0//EN"
"http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd">
<hibernate-mapping>
    <class name="example.business.Message" table="tb_message">
        <id name="id" type="int" column="id">
        	<generator class="native" />
        </id>
        <property name="userId" type="int" column="userId" />
        <property name="content" type="string" column="content" />
        <property name="createdTime" type="datetime" column="createdTime" />
    </class>
</hibernate-mapping>
}}}

在mb_main数据库中增加tb_user表，并调整tb_message表：
{{{
use mb_main ;

create table tb_user(
	id int not null auto_increment primary key, 
	userName varchar(64) not null, 
	messageCount int(11)default 0
)engine=Innodb ;

alter table tb_message add column userId int(11) default 1 ;
create index idx_msg_uid on tb_message(userId) ;

insert into tb_user(userName) values('Lucy') ;
insert into tb_user(userName) values('Lily') ;
insert into tb_user(userName) values('Cathy') ;
insert into tb_user(userName) values('Polly, The Bird') ;

update tb_user set messageCount = (select count(*) from tb_message) where id = 1 ;

}}}

修改guzz.xml，增加User域对象声明：
{{{
<business dbgroup="default" name="user" file="classpath:example/business/User.hbm.xml" />
}}}

由于是多用户留言板，因此 messageList.jsp 我们需要增加一个参数来区分用户。此参数定义为userId。无论是访问留言板，还是发表留言，我们都用userId标记当前留言板所属用户。修改 messageList.jsp 增加对userId参数的支持：
{{{
<%@ page language="java" pageEncoding="UTF-8"%>
<%@include file="/WEB-INF/jsp/include/tags.jsp"%>
<g:get business="user" var="m_user" limit="id=${param.userId}" />

<g:boundary>
	<g:addLimit limit="userId=${m_user.id}" />
	<g:page business="message" var="m_messages" tableCondition="${m_user.id}" pageNo="${param.pageNo}" pageSize="30" orderBy="id desc" scope="request" />
</g:boundary>

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
  <head>    
    <title>${m_user.userName}'s Message List</title>
  </head>
  
  <body>  	 
  	Leave a message:<br>  	

  	<form method="POST" action="./newMessage.do">
  		<input type="hidden" name="userId" value="${m_user.id}" />
  		
  		<textarea name="content" cols="80" rows="10"></textarea>  		
  		....
}}}

在新的 messageList.jsp 中，g:page增加了1个查询条件。而在form表单提交时，增加了隐藏的userId参数。

修改NewMessageAction.java 增加对userId参数的支持：
{{{
	public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) throws Exception {
		int userId = RequestUtil.getParameterAsInt(request, "userId", 0) ;
		String content = request.getParameter("content") ;

		Message msg = new Message() ;
		msg.setContent(content) ;
		msg.setCreatedTime(new java.util.Date()) ;
		
		//close auto-commit
		WriteTranSession write = guzzContext.getTransactionManager().openRWTran(false) ;
		
		try{
			User user = (User) write.findObjectByPK(User.class, userId) ;
			user.setMessageCount(user.getMessageCount() + 1) ;
			
			msg.setUserId(userId) ;
			
			write.insert(msg) ;
			write.update(user) ;
			
			write.commit() ;
		}catch(Exception e){
			write.rollback() ;
			
			throw e ;
		}finally{
			write.close() ;
		}
		
		return new ModelAndView("redirect:/messageList.jsp", "userId", userId);
	}
}}}

因为要同时更新两张表，因此我们选择手工控制事务的提交。

重新部署并启动应用，访问：http://localhost:8080/guzz/messageList.jsp?userId=1 ，看到Lucy's Message List；访问 http://localhost:8080/guzz/messageList.jsp?userId=1 看到Lily's Message List。

多用户留言板完成。


== 使用2组数据库（启用第3，4台数据库） ==

 随着业务的增长我们发现mb_main数据库负载太高，需要将tb_user表挪出去，部署到另外一组数据库中。这组数据库有1台主库（第3台数据库）和1台从库（第4台数据库）。

 我们给这组新数据库取名为userDB。首先，很显然需要将现有的tb_user表导出并装载到userDB数据库组中，并建好数据库主从。假设此步骤已经完成。

 为了演示，我们在本机上创建 mb_user 数据库作为userDB。
{{{
create database mb_user default character set utf8 ;

create table mb_user.tb_user select * from mb_main.tb_user ;

alter table mb_user.tb_user modify column id int(11) not null auto_increment primary key ;

drop table mb_main.tb_user ;

}}}

 这时我们有2组数据库：mb_main存放tb_message, mb_user存放tb_user。

 为了让应用知道mb_user的存在，修改guzz.xml的tran，增加一个userDB dbgroup：
 {{{<dbgroup name="userDB" masterDBConfigName="userMasterDB" slaveDBConfigName="userSlaveDB" />}}}

 修改User域对象使用userDB：
 {{{<business dbgroup="userDB" name="user" file="classpath:example/business/User.hbm.xml" />}}}

 修改messageBoard.properties主配置文件，增加userDB对主从数据库连接池的配置信息[userMasterDB]和[userSlaveDB]:

{{{
[userMasterDB]
guzz.identifer=userMasterDB1
guzz.IP=localhost
guzz.maxLoad=120
driverClass=com.mysql.jdbc.Driver
jdbcUrl=jdbc:mysql://localhost:3306/mb_user?useUnicode=true&amp;characterEncoding=UTF-8&amp;useServerPrepStmts=true
user=root
password=root
acquireIncrement=10
idleConnectionTestPeriod=60

[userSlaveDB]
guzz.identifer=userSlaveDB1
guzz.IP=localhost
guzz.maxLoad=80
driverClass=com.mysql.jdbc.Driver
jdbcUrl=jdbc:mysql://localhost:3306/mb_user?useUnicode=true&amp;characterEncoding=UTF-8&amp;useServerPrepStmts=true
user=root
password=root
acquireIncrement=10
idleConnectionTestPeriod=60
}}}

如果你有第3，4台独立数据库，将上面的jdbcUrl改到具体的数据库地址即可。

重新部署并启动应用，这时您的应用已经开始使用4台数据库。当你发表新留言时，更新tb_user和tb_message表的操作将自动在一个分布式事务中完成。代码不需要做任何调整。

== 将留言表分切成小表 ==

随着业务的进一步发展，很快留言数突破千万，tb_message查询缓慢，已经成为系统的性能瓶颈。我们决定将留言表按照用户分成多张小表。

分切的规则是：每个用户1张表，表名规则为tb_message_${userId}。

切表的详细说明文档，请参看：[TutorialShadowTable] 。为了实现表分切，首先需要实现分切规则，创建一个新的java类example.business.MessageShadowTableView定义规则：
{{{
package example.business;

import org.guzz.exception.GuzzException;
import org.guzz.orm.AbstractShadowTableView;

public class MessageShadowTableView extends AbstractShadowTableView {

	public String toTableName(Object tableCondition) {
		if (tableCondition == null) { // 强制要求必须设置表分切条件，避免编程时疏忽。
			throw new GuzzException("null table conditon is not allowed.");
		}

		Integer userId = (Integer) tableCondition;

		//tb_message_${userId}
		return "tb_message_" + userId.intValue() ;
	}

}
}}}

可见，分切条件为用户编号userId。我们有4个用户，因此将tb_message分切成4张小表，分别为：tb_message_1, tb_message_2, tb_message_3, tb_message_4.
{{{
use mb_main ;

create table tb_message_1 select * from tb_message where userId = 1 ;
create table tb_message_2 select * from tb_message where userId = 2 ;
create table tb_message_3 select * from tb_message where userId = 3 ;
create table tb_message_4 select * from tb_message where userId = 4 ;

alter table tb_message_1 modify column id int(11) not null auto_increment primary key ;
alter table tb_message_2 modify column id int(11) not null auto_increment primary key ;
alter table tb_message_3 modify column id int(11) not null auto_increment primary key ;
alter table tb_message_4 modify column id int(11) not null auto_increment primary key ;

drop table tb_message ;
}}}

为了让guzz知道表分切规则，修改Message.hbm.xml映射文件，在class元素中增加属性 shadow="example.business.MessageShadowTableView" ，同时将dtd定义改成guzz的。修改的文件为：
{{{
<?xml version="1.0"?>
<!DOCTYPE guzz-mapping PUBLIC "-//GUZZ//GUZZ MAPPING DTD//EN" "http://www.guzz.org/dtd/guzz-mapping.dtd">
<guzz-mapping>
    <class name="example.business.Message" table="tb_message" shadow="example.business.MessageShadowTableView">
        <id name="id" type="int" column="id">
        	<generator class="native" />
        </id>
        <property name="userId" type="int" column="userId" />
        <property name="content" type="string" column="content" />
        <property name="createdTime" type="datetime" column="createdTime" />
    </class>
</guzz-mapping>
}}}

这是guzz已经知道Message对象需要根据 example.business.MessageShadowTableView 进行切表。在所有操作 Message 的地方，需要传入userId作为切表条件（称作：tableCondition）。

对于读取的地方，修改 messageList.jsp 的g:page调用为：
{{{<g:page business="message" var="m_messages" tableCondition="${param.userId}" pageNo="${param.pageNo}" pageSize="30" orderBy="id desc" scope="request" />}}}

通过tableCondition属性传入切表条件。

修改 NewMessageAction.java的 write.insert(msg) ; 为 write.insert(msg, userId) ; 通过insert方法的第二个参数传入切表条件。

重新部署并启动应用，可以看到我们的留言板已经在4个小表中工作了。


== 分布式切表以应对超级大表 ==

随着业务的更进一步发展，我们发现tb_message即使分成了小表，都存储在一台数据库中也过于庞大。在实际的应用中，可能是您的数据已经分切成了上百张表，总量比较大。我们需要将这些分切后的小表，存储到不同的数据库机器中，减少单台数据库数据量过大的问题，同时也减少表的个数。

为了解决这个问题，guzz提供了分布式切表功能，称作VirtualDB。详细介绍请参看：[TutorialVirtualDB]

为了演示，我们个性化的小表存储规则为：编号为1的用户，留言存储在default数据库组中不变；其他的存储到userDB中。当然在实际使用中，您可能不会这么做，并且引入第5，6，7，8甚至更多台的数据库机器。

现在我们开始挪表，把tb_message_2, tb_message_3, tb_message_4从mb_main挪到mb_user中：
{{{
create table mb_user.tb_message_2 select * from mb_main.tb_message_2 ;
create table mb_user.tb_message_3 select * from mb_main.tb_message_3 ;
create table mb_user.tb_message_4 select * from mb_main.tb_message_4 ;

alter table mb_user.tb_message_2 modify column id int(11) not null auto_increment primary key ;
alter table mb_user.tb_message_3 modify column id int(11) not null auto_increment primary key ;
alter table mb_user.tb_message_4 modify column id int(11) not null auto_increment primary key ;

drop table mb_main.tb_message_2 ;
drop table mb_main.tb_message_3 ;
drop table mb_main.tb_message_4 ;
}}}

创建一个新的java类，定义VirtualDB的表分布规则：
{{{
package example.business;

import org.guzz.connection.AbstractVirtualDBView;
import org.guzz.exception.GuzzException;

public class MessageVirtualDBView extends AbstractVirtualDBView {
    
    public String getPhysicsDBGroupName(Object tableCondition) {
		if (tableCondition == null) {
			throw new GuzzException("null table conditon is not allowed.");
		}
		
		int userId = (Integer) tableCondition;
		
		if(userId == 1){
			 //store lucy's messages in the default database.
			return "default" ;
		}else{
			 //store others in the userDB database.
			return "userDB" ;
		}
    }

}
}}}

为了让 guzz 知道分布式切表，对于每个使用VirtualDB的表，我们需要在guzz.xml中声明一个virtualdbgroup。对于Message，修改guzz.xml，在tran元素下增加virtualdbgroup：
{{{<virtualdbgroup name="messageDB" shadow="example.business.MessageVirtualDBView" />}}}

同时，修改Message领域对象的dbgroup到新的messageDB。修改好的guzz.xml为：
{{{
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE guzz-configs PUBLIC "-//GUZZ//DTD MAIN CONFIG//EN" "http://www.guzz.org/dtd/guzz.dtd">

<guzz-configs>
	
	<dialect class="org.guzz.dialect.Mysql5Dialect" />
	
	<tran>
		<dbgroup name="default" masterDBConfigName="masterDB" slaveDBConfigName="slaveDB" />
		<dbgroup name="userDB" masterDBConfigName="userMasterDB" slaveDBConfigName="userSlaveDB" />
		
		<virtualdbgroup name="messageDB" shadow="example.business.MessageVirtualDBView" />
	</tran>
	
	<config-server>
		<server class="org.guzz.config.LocalFileConfigServer">
			<param name="resource" value="messageBoard.properties" />
		</server>
	</config-server>
	
	<!-- business starts -->
	<business dbgroup="messageDB" name="message" file="classpath:example/business/Message.hbm.xml" />
	<business dbgroup="userDB" name="user" file="classpath:example/business/User.hbm.xml" />
	<!-- business ends -->

</guzz-configs>
}}}

重新部署并启动应用。此时的留言板将自动将lucy的留言存储到mb_main，其他人的留言存储到mb_user库中。完成分布式切表。